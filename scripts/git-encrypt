#!/usr/bin/env python3
# Source Code for maxchernoff.ca
# https://github.com/gucci-on-fleek/maxchernoff.ca
# SPDX-License-Identifier: MPL-2.0+ OR CC-BY-SA-4.0+
# SPDX-FileCopyrightText: 2025 Max Chernoff

# Manually updating all of the secrets in the project is fragile and
# error-prone, so instead, it would be best to store them in Git. However, since
# I would like to store the repository on GitHub, it would be best to encrypt
# the secrets before committing them. The most transparent way to do this is
# with Git smudge/clean filters. However, for these to work properly, we need
# for the encryption to be deterministic---that is, for a given key and input,
# the output must always be the same. This is a problem because most of the
# standard Linux encryption tools either unconditionally generate a random nonce
# for each invocation, let you specify a nonce but use algorithms that are
# unsafe if the nonce is ever reused, or are far too heavyweight. So
# unfortunately, I'm left with rolling my own crypto, which is generally a
# horrible idea.

###############
### Imports ###
###############
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from base64 import b85decode, b85encode
from bz2 import compress, decompress
from itertools import batched
from os import getenv
from sys import exit, stderr, stdin, stdout
from typing import Callable, cast

from cryptography.exceptions import InvalidTag
from cryptography.hazmat.primitives.ciphers.aead import AESGCMSIV
from cryptography.hazmat.primitives.hashes import BLAKE2b, Hash


####################
### Type Aliases ###
####################

type CommandFunction = Callable[[bytes, bytes, bytes], bytes]
type KeyFunction = Callable[[], bytes]


#################
### Constants ###
#################

LINE_LENGTH = 80  # Length of each line in the output
KEY_BITS = 256  # AES key size in bits
KEY_BYTES = KEY_BITS // 8  # AES key size in bytes
NONCE_BYTES = 12  # AES nonce size in bytes
DIGEST_BYTES = 64  # BLAKE2b digest length in bytes
FILE_HEADER = "https://github.com/gucci-on-fleek/maxchernoff.ca/ git-encrypt v1"  # Header for the encrypted file


#########################
### Class Definitions ###
#########################


class InvalidArgumentError(ValueError):
    """Custom exception for invalid arguments."""

    pass


############################
### Function Definitions ###
############################


def encode(data: bytes) -> str:
    """Encodes and chunks the input data using base85 encoding."""
    encoded = b85encode(data).decode("utf-8")
    chunked = "\n".join("".join(s) for s in batched(encoded, LINE_LENGTH))
    return chunked


def decode(data: str) -> bytes:
    """Decodes the input data using base85 decoding."""
    unchunked = data.replace("\n", "")
    decoded = b85decode(unchunked)
    return decoded


def parse_key(env: str | None) -> bytes:
    """Parse the key from the environment variable."""
    if env is None:
        raise InvalidArgumentError(
            "GIT_ENCRYPT_KEY environment variable is required"
        )

    try:
        key = decode(env)
    except ValueError:
        raise InvalidArgumentError(
            "Invalid key format. Must be base85 encoded."
        )

    if len(key) != KEY_BYTES:
        raise InvalidArgumentError("Invalid key length. Must be 32 bytes.")

    return key


def generate_key() -> bytes:
    """Generate a new key."""
    key_bytes = AESGCMSIV.generate_key(KEY_BITS)
    key_encoded = encode(key_bytes)
    return key_encoded.encode("utf-8") + b"\n"


def encrypt(key: bytes, data: bytes, filename: bytes) -> bytes:
    """Encrypt the input data using the key."""
    # First, we will compress the data using bzip2. This isn't strictly
    # necessary; however, later we will be encoding the data using base85 which
    # will increase the size by 25%, so by compressing the data first, we can
    # hopefully counteract this.
    data = compress(data)

    # Next, we need to generate an Initialization Vector (IV) to use for the
    # encryption. We want this to be deterministic, so using a CSPRNG is not an
    # option here. But we also want to ensure that the IV is unique for each
    # encryption, so we can't just use a fixed IV. Instead, we'll hash the
    # plaintext combined with the filename to generate the IV. This ensures that
    # the IV is unique for each file, but also deterministic. And by including
    # the filename in the hash, we ensure that we don't reveal to an attacker
    # that two files are identical.
    digest = Hash(BLAKE2b(digest_size=DIGEST_BYTES))

    # Note that Blake2 is specifically designed to be immune to length-extension
    # attacks, so it's safe to combine the plaintext and filename in this way.
    # For other hashing algorithms, we would need to use an HMAC or similar.
    digest.update(data)
    digest.update(filename)
    nonce = digest.finalize()[:NONCE_BYTES]

    # Now, we can encrypt the data using the nonce and the key. We're using
    # AES-GCM-SIV here since it is nonce-misuse resistant. That is, reusing the
    # nonce with the same key only reveals if two plaintexts are identical, but
    # does not reveal any other information about the plaintexts. This isn't
    # strictly necessary here since hashing the plaintext should ensure that we
    # never reuse the nonce for different plaintexts, but it is still highly
    # recommended since our nonce is neither random nor a counter.
    #
    # AES-GCM-SIV is also an AEAD (Authenticated Encryption with Associated
    # Data) mode, which means that we can guarantee that an attacker without
    # knowledge of the key cannot modify the ciphertext without detection. Since
    # this is an AEAD mode, we can also bind additional non-secret data to the
    # ciphertext, which we will use to bind the filename to the ciphertext so
    # that an attacker cannot move or rename the encrypted file without
    # detection.
    cipher = AESGCMSIV(key)
    encrypted = cipher.encrypt(nonce, data, filename)

    # Now, we will encode the ciphertext `bytes` into a `str`. We will use
    # base85 chunked at 80 characters per line since this is fairly well-behaved
    # with text-based tools. We could just write the raw bytes to the output,
    # but binary files work fairly poorly with Git.
    encoded = encode(encrypted)

    # Finally, we will join the header, nonce, and ciphertext together
    return "\n".join([FILE_HEADER, encode(nonce), encoded, ""]).encode("utf-8")


def decrypt(key: bytes, data: bytes, filename: bytes) -> bytes:
    """Decrypt the input data using the key."""
    # First, we need to split the input data into the header, nonce, and
    # ciphertext.
    data: str = data.decode("utf-8")
    lines = data.split("\n")
    header = lines[0]
    nonce = lines[1]
    ciphertext = "\n".join(lines[2:])

    # Now, we need to make sure that the header is valid.
    if header != FILE_HEADER:
        raise InvalidArgumentError("Invalid header. Must be 'git-encrypt v1'")

    # Next, we need to decode the ciphertext and nonce.
    try:
        nonce = decode(nonce)
        ciphertext = decode(ciphertext)
    except ValueError:
        raise InvalidArgumentError(
            "Invalid nonce or ciphertext format. Must be base85 encoded."
        )

    # Now we need to make sure that the nonce is the correct length.
    if len(nonce) != NONCE_BYTES:
        raise InvalidArgumentError("Invalid nonce length. Must be 12 bytes.")

    # Now, we can decrypt the ciphertext using the nonce and the key.
    cipher = AESGCMSIV(key)
    try:
        decrypted = cipher.decrypt(nonce, ciphertext, filename)
    except InvalidTag:
        raise InvalidArgumentError(
            "Invalid key or ciphertext. Decryption failed."
        )

    # Finally, we need to decompress the decrypted data.
    output = decompress(decrypted)
    return output


###################
### Entry Point ###
###################

if __name__ == "__main__":
    # Generate the argument parser
    parser = ArgumentParser(
        formatter_class=RawDescriptionHelpFormatter,
        description="A Git smudge/clean filter for transparently encrypting files.",
        epilog="""
environment variables:
  $GIT_ENCRYPT_KEY      The key to use for encryption

usage:
  .git/config:
    [filter "git-encrypt"]
    clean = ./scripts/git-encrypt encrypt %f
    smudge = ./scripts/git-encrypt decrypt %f
    required

  .gitattributes:
    *.enc filter=git-encrypt
  """.strip(),
    )

    subparsers = parser.add_subparsers(
        title="commands",
        required=True,
    )

    filename_args = ArgumentParser(add_help=False)
    filename_args.add_argument(
        "filename",
        type=str,
        help="The name of the piped file",
    )

    encrypt_args = subparsers.add_parser(
        "encrypt",
        help="Encrypt the input",
        parents=[filename_args],
    )
    encrypt_args.set_defaults(func=encrypt)

    decrypt_args = subparsers.add_parser(
        "decrypt",
        help="Decrypt the input",
        parents=[filename_args],
    )
    decrypt_args.set_defaults(func=decrypt)

    keygen_args = subparsers.add_parser("keygen", help="Generate a new key")
    keygen_args.set_defaults(func=generate_key)

    # Parse the arguments
    args = parser.parse_args()
    func: CommandFunction | KeyFunction = args.func

    # Handle the subcommands
    try:
        if func in (generate_key,):
            func = cast(KeyFunction, func)

            output_data = func()
        elif func in (encrypt, decrypt):
            func = cast(CommandFunction, func)

            key = parse_key(getenv("GIT_ENCRYPT_KEY"))
            filename: bytes = args.filename.encode("utf-8")

            input_data = stdin.buffer.read()
            output_data = func(key, input_data, filename)
        else:
            raise InvalidArgumentError("Invalid command")
    except InvalidArgumentError as e:
        parser.error(str(e))

    stdout.buffer.write(output_data)
    exit(0)
