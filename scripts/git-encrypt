#!/usr/bin/env python3
# Source Code for maxchernoff.ca
# https://github.com/gucci-on-fleek/maxchernoff.ca
# SPDX-License-Identifier: MPL-2.0+ OR CC-BY-SA-4.0+
# SPDX-FileCopyrightText: 2025 Max Chernoff

# Manually updating all of the secrets in the project is fragile and
# error-prone, so instead, it would be best to store them in Git. However, since
# I would like to store the repository on GitHub, it would be best to encrypt
# the secrets before committing them.
#
# The most transparent way to do this is with Git smudge/clean filters. However,
# for these to work properly, we need for the encryption to be deterministic---
# that is, for a given key and input, the output must always be the same. This
# is a problem because most of the standard Linux encryption tools either
# unconditionally generate a random nonce for each invocation, let you specify a
# nonce but use algorithms that are unsafe if the nonce is ever reused.
#
# This script is very similar to the `git-crypt` tool
#
#     https://github.com/AGWA/git-crypt
#
# except that this tool uses slightly different cryptographic primitives its
# implementation is considerably simpler.


###############
### Imports ###
###############

import lzma
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from base64 import b85decode, b85encode
from itertools import batched
from os import getenv
from sys import exit, stdin, stdout
from typing import Callable, cast

from cryptography.exceptions import InvalidTag
from cryptography.hazmat.primitives.ciphers.aead import AESGCMSIV
from cryptography.hazmat.primitives.hashes import BLAKE2b, Hash


####################
### Type Aliases ###
####################

type CommandFunction = Callable[[bytes, bytes, bytes], bytes]
type KeyFunction = Callable[[], bytes]


#################
### Constants ###
#################

DIGEST_BYTES = 64  # BLAKE2b digest length in bytes
FILE_HEADER = (
    "github.com/gucci-on-fleek/maxchernoff.ca",
    "git-encrypt",
    "v1",
)  # Header for the encrypted file
KEY_BITS = 256  # AES key size in bits
KEY_BYTES = KEY_BITS // 8  # AES key size in bytes
KNOWN_VERSIONS = ("v1",)  # Known versions of the file format
LINE_LENGTH = 80  # Length of each line in the output
LZMA_FILTERS = [
    {"id": lzma.FILTER_LZMA2, "preset": lzma.PRESET_DEFAULT}
]  # Filters to use for LZMA compression, required for FORMAT_RAW
LZMA_FORMAT = (
    lzma.FORMAT_RAW
)  # Don't include the header and checksum in the compressed data
NONCE_BYTES = 12  # AES nonce size in bytes


#########################
### Class Definitions ###
#########################


class InvalidArgumentError(ValueError):
    """Custom exception raised when invalid arguments are passed."""

    pass


############################
### Function Definitions ###
############################


def encode(data: bytes) -> str:
    """Encodes and chunks the input data using base85 encoding."""

    encoded = b85encode(data).decode("utf-8")
    chunked = "\n".join("".join(s) for s in batched(encoded, LINE_LENGTH))
    return chunked


def decode(data: str) -> bytes:
    """Decodes the input data using base85 decoding."""

    unchunked = data.replace("\n", "")
    decoded = b85decode(unchunked)
    return decoded


def compress(data: bytes) -> bytes:
    """Compress the input data."""

    compressed = lzma.compress(data, format=LZMA_FORMAT, filters=LZMA_FILTERS)
    return compressed


def decompress(data: bytes) -> bytes:
    """Decompress the input data."""

    decompressed = lzma.decompress(data, format=LZMA_FORMAT)
    return decompressed


def parse_key(env: str | None) -> bytes:
    """Parse the key from the environment variable."""

    if env is None:
        raise InvalidArgumentError(
            '"$GIT_ENCRYPT_KEY" environment variable is not set.'
        )

    try:
        key = decode(env)
    except ValueError:
        raise InvalidArgumentError(
            "Invalid key format. Must be base85 encoded."
        )

    if len(key) != KEY_BYTES:
        raise InvalidArgumentError("Invalid key length. Must be 32 bytes.")

    return key


def encrypt(key: bytes, data: bytes, filename: bytes) -> bytes:
    """Encrypt the input data using the key."""

    # First, we will compress the data using lzma. This isn't strictly
    # necessary; however, later we will be encoding the data using base85 which
    # will increase the size by 25%, so by compressing the data first, we can
    # hopefully counteract this.
    data = compress(data)

    # Next, we need to generate an Initialization Vector (IV) to use for the
    # encryption. We want this to be deterministic, so using a CSPRNG is not an
    # option here. But we also want to ensure that the IV is unique for each
    # encryption, so we can't just use a fixed IV. Instead, we'll hash the
    # plaintext combined with the filename to generate the IV. This ensures that
    # the IV is unique for each file, but also deterministic. And by including
    # the filename in the hash, we ensure that we don't reveal to an attacker
    # that two files are identical.
    digest = Hash(BLAKE2b(digest_size=DIGEST_BYTES))

    # Note that Blake2 is specifically designed to be immune to length-extension
    # attacks, so it's safe to merely concatenate the  plaintext and filename
    # when creating the hash. For other hashing algorithms, we would need to use
    # an HMAC or similar construction to ensure that the hash is secure.
    digest.update(data)
    digest.update(filename)
    nonce = digest.finalize()[:NONCE_BYTES]

    # Now, we can encrypt the data using the nonce and the key. We're using
    # AES-GCM-SIV here since it is nonce-misuse resistant. That is, reusing the
    # nonce with the same key only reveals if two plaintexts are identical, but
    # does not reveal any other information about the plaintexts. This isn't
    # strictly necessary here since hashing the plaintext should ensure that we
    # never reuse the nonce for different plaintexts, but it is still highly
    # recommended since our nonce is neither random nor a counter.
    #
    # AES-GCM-SIV is also an AEAD (Authenticated Encryption with Associated
    # Data) mode, which means that we can guarantee that an attacker without
    # knowledge of the key cannot modify the ciphertext without detection. Since
    # this is an AEAD mode, we can also bind additional non-secret data to the
    # ciphertext, which we will use to bind the filename to the ciphertext so
    # that an attacker cannot move or rename the encrypted file without
    # detection.
    cipher = AESGCMSIV(key)
    encrypted = cipher.encrypt(nonce, data, filename)

    # Now, we will encode the ciphertext `bytes` into a `str`. We will use
    # base85 chunked at 80 characters per line since this is fairly well-behaved
    # with text-based tools. We could just write the raw bytes to the output,
    # but binary files work fairly poorly with Git.
    encoded = encode(encrypted)

    # Finally, we will join the header, nonce, and ciphertext together
    return "\n".join(
        [
            " ".join(FILE_HEADER),
            encode(nonce),
            encoded,
            "",
        ]
    ).encode("utf-8")


def decrypt(key: bytes, data: bytes, filename: bytes) -> bytes:
    """Decrypt the input data using the key."""

    # First, we need to split the input data into the header, nonce, and
    # ciphertext.
    data: str = data.decode("utf-8")
    lines = data.split("\n")
    header = lines[0].split(" ")
    nonce = lines[1]
    ciphertext = "\n".join(lines[2:])

    # Now, we need to make sure that the header is valid.
    if (*header[:2],) != FILE_HEADER[:2]:
        raise InvalidArgumentError(
            'Invalid header. Are you sure this is a "git-encrypt"ed file?'
        )

    if header[2] not in KNOWN_VERSIONS:
        raise InvalidArgumentError(
            f'Invalid version. "{header[2]}" was passed, but only {KNOWN_VERSIONS} are supported.'
        )

    # Next, we will try to decode the ciphertext and nonce.
    try:
        nonce = decode(nonce)
        ciphertext = decode(ciphertext)
    except ValueError:
        raise InvalidArgumentError(
            "Invalid nonce or ciphertext format. Must be base85 encoded."
        )

    # Now we need to make sure that the nonce is the correct length.
    if len(nonce) != NONCE_BYTES:
        raise InvalidArgumentError("Invalid nonce length. Must be 12 bytes.")

    # Now, we can decrypt the ciphertext using the nonce and the key.
    cipher = AESGCMSIV(key)
    try:
        decrypted = cipher.decrypt(nonce, ciphertext, filename)
    except InvalidTag:
        raise InvalidArgumentError(
            "Invalid key or ciphertext. Decryption failed."
        )

    # Finally, we need to decompress the decrypted data.
    output = decompress(decrypted)
    return output


def generate_key() -> bytes:
    """Generate a new random key."""

    key_bytes = AESGCMSIV.generate_key(KEY_BITS)
    key_encoded = encode(key_bytes)
    return key_encoded.encode("utf-8") + b"\n"


###################
### Entry Point ###
###################

if __name__ == "__main__":
    # Generate the root argument parser for the script
    parser = ArgumentParser(
        formatter_class=RawDescriptionHelpFormatter,
        description="A Git smudge/clean filter for transparently encrypting files.",
        epilog="""
environment variables:
  $GIT_ENCRYPT_KEY      The key to use for encryption

usage:
  .git/config:
    [filter "git-encrypt"]
    clean = ./scripts/git-encrypt encrypt %f
    smudge = ./scripts/git-encrypt decrypt %f
    required

  .gitattributes:
    *.enc filter=git-encrypt
  """.strip(),
    )

    # Add subparsers for each command
    subparsers = parser.add_subparsers(
        title="commands",
        required=True,
    )

    filename_args = ArgumentParser(add_help=False)
    filename_args.add_argument(
        "filename",
        type=str,
        help="The name of the piped file",
    )

    encrypt_args = subparsers.add_parser(
        "encrypt",
        help="Encrypt the input",
        parents=[filename_args],
    )
    encrypt_args.set_defaults(func=encrypt)

    decrypt_args = subparsers.add_parser(
        "decrypt",
        help="Decrypt the input",
        parents=[filename_args],
    )
    decrypt_args.set_defaults(func=decrypt)

    keygen_args = subparsers.add_parser("keygen", help="Generate a new key")
    keygen_args.set_defaults(func=generate_key)

    # Parse the arguments
    args = parser.parse_args()
    func: CommandFunction | KeyFunction = args.func

    # Handle the subcommands
    try:
        if func in (generate_key,):
            func = cast(KeyFunction, func)

            output_data = func()
        elif func in (encrypt, decrypt):
            func = cast(CommandFunction, func)

            key = parse_key(getenv("GIT_ENCRYPT_KEY"))
            filename: bytes = args.filename.encode("utf-8")

            input_data = stdin.buffer.read()
            output_data = func(key, input_data, filename)
        else:
            raise InvalidArgumentError("Invalid command")
    except InvalidArgumentError as e:
        parser.error(str(e))

    # Write the output to stdout
    stdout.buffer.write(output_data)
    exit(0)
